From f2132ea836136533a00be5c54f1e0f0154b9378b Mon Sep 17 00:00:00 2001
From: Dimitar Dimitrov <dimitar@dinux.eu>
Date: Thu, 11 Apr 2019 20:17:57 +0300
Subject: [PATCH 2/3] WIP - add CARRY support

TODO - add test cases for the improvement!

PASS->FAIL: gcc.dg/setjmp-1.c spurious clobbered warning (test for bogus messages, line 17)
  -> PR/21161 is exposed by this change.

Signed-off-by: Dimitar Dimitrov <dimitar@dinux.eu>
---
 gcc/config/pru/alu-zext.md             | 287 +++++++++++-
 gcc/config/pru/constraints.md          |   5 +
 gcc/config/pru/predicates.md           |  12 +
 gcc/config/pru/pru-modes.def           |  21 +
 gcc/config/pru/pru-protos.h            |   2 +
 gcc/config/pru/pru.c                   | 115 ++++-
 gcc/config/pru/pru.h                   |  22 +-
 gcc/config/pru/pru.md                  | 597 ++++++++++++++++++++++---
 gcc/testsuite/gcc.target/pru/adddi-1.c |  14 +
 gcc/testsuite/gcc.target/pru/adddi-2.c |  14 +
 gcc/testsuite/gcc.target/pru/adddi-3.c |  14 +
 gcc/testsuite/gcc.target/pru/negdi-1.c |  14 +
 gcc/testsuite/gcc.target/pru/subdi-1.c |  14 +
 gcc/testsuite/gcc.target/pru/subdi-2.c |  14 +
 14 files changed, 1023 insertions(+), 122 deletions(-)
 create mode 100644 gcc/config/pru/pru-modes.def
 create mode 100644 gcc/testsuite/gcc.target/pru/adddi-1.c
 create mode 100644 gcc/testsuite/gcc.target/pru/adddi-2.c
 create mode 100644 gcc/testsuite/gcc.target/pru/adddi-3.c
 create mode 100644 gcc/testsuite/gcc.target/pru/negdi-1.c
 create mode 100644 gcc/testsuite/gcc.target/pru/subdi-1.c
 create mode 100644 gcc/testsuite/gcc.target/pru/subdi-2.c

diff --git a/gcc/config/pru/alu-zext.md b/gcc/config/pru/alu-zext.md
index 65916c70d65..c2ad2116426 100644
--- a/gcc/config/pru/alu-zext.md
+++ b/gcc/config/pru/alu-zext.md
@@ -32,55 +32,59 @@
 
 
 (define_subst_attr "alu2_zext"     "alu2_zext_subst"     "_z" "_noz")
+(define_subst_attr "alu2c_zext"    "alu2c_zext_subst"    "_z" "_noz")
 
 (define_subst_attr "alu3_zext_op1" "alu3_zext_op1_subst" "_z1" "_noz1")
 (define_subst_attr "alu3_zext_op2" "alu3_zext_op2_subst" "_z2" "_noz2")
 (define_subst_attr "alu3_zext"     "alu3_zext_subst"     "_z" "_noz")
 
+(define_subst_attr "addsub3_zext_op1" "addsub3_zext_op1_subst" "_csz1" "_csnoz1")
+(define_subst_attr "addsub3_zext_op2" "addsub3_zext_op2_subst" "_csz2" "_csnoz2")
+(define_subst_attr "addsub3_zext"     "addsub3_zext_subst"     "_csz" "_csnoz")
+
+(define_subst_attr "alucc3_zext_op1" "alucc3_zext_op1_subst" "_ccz1" "_ccnoz1")
+(define_subst_attr "alucc3_zext_op2" "alucc3_zext_op2_subst" "_ccz2" "_ccnoz2")
+(define_subst_attr "alucc3_zext"     "alucc3_zext_subst"     "_ccz" "_ccnoz")
+
 (define_subst_attr "bitalu_zext"   "bitalu_zext_subst"   "_z" "_noz")
 
 (define_code_iterator ALUOP3 [plus minus and ior xor umin umax ashift lshiftrt])
-(define_code_iterator ALUOP2 [neg not])
+(define_code_iterator PLUSMINUS3 [plus minus])
+(define_code_iterator ALUOP2 [not])
 
 ;; Arithmetic Operations
 
-(define_insn "add_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>"
+(define_insn "add_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alucc3_zext><alucc3_zext_op1><alucc3_zext_op2><addsub3_zext_op1><addsub3_zext_op2><addsub3_zext>"
   [(set (match_operand:EQD 0 "register_operand" "=r,r,r")
 	(plus:EQD
-	 (zero_extend:EQD
-	  (match_operand:EQS0 1 "register_operand" "%r,r,r"))
-	 (zero_extend:EQD
-	  (match_operand:EQS1 2 "nonmemory_operand" "r,<EQS1:ubyte_constr>,M"))))]
-  ""
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "register_operand" "%r,r,r"))
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "reg_or_m255p255_operand" "r,<EQS1:ubyte_constr>,M"))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  "reload_completed"
   "@
    add\\t%0, %1, %2
    add\\t%0, %1, %u2
    sub\\t%0, %1, %n2"
-  [(set_attr "type" "alu")])
+  [(set_attr "type" "alu")
+   (set_attr "length" "4")])
 
-(define_insn "sub_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alu3_zext><alu3_zext_op1><alu3_zext_op2>"
+(define_insn "sub_impl<EQD:mode><EQS0:mode><EQS1:mode>_<alucc3_zext><alucc3_zext_op1><alucc3_zext_op2><addsub3_zext_op1><addsub3_zext_op2><addsub3_zext>"
   [(set (match_operand:EQD 0 "register_operand" "=r,r")
 	(minus:EQD
-	 (zero_extend:EQD
-	  (match_operand:EQS0 1 "reg_or_ubyte_operand" "r,<EQS0:ubyte_constr>"))
-	 (zero_extend:EQD
-	  (match_operand:EQS1 2 "register_operand" "r,r"))))]
-  ""
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "reg_or_ubyte_operand" "r,<EQS0:ubyte_constr>"))
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "register_operand" "r,r"))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  "reload_completed"
   "@
    sub\\t%0, %1, %2
    rsb\\t%0, %2, %u1"
   [(set_attr "type" "alu")])
 
 
-(define_insn "neg_impl<EQD:mode><EQS0:mode>_<alu2_zext>"
-  [(set (match_operand:EQD 0 "register_operand" "=r")
-	(neg:EQD
-	  (zero_extend:EQD (match_operand:EQS0 1 "register_operand" "r"))))]
-  ""
-  "rsb\\t%0, %1, 0"
-  [(set_attr "type" "alu")])
-
-
 (define_insn "one_cmpl_impl<EQD:mode><EQS0:mode>_<alu2_zext>"
   [(set (match_operand:EQD 0 "register_operand" "=r")
 	(not:EQD
@@ -144,6 +148,14 @@ (define_subst "alu2_zext_subst"
   [(set (match_dup 0)
 	(ALUOP2:EQD (match_dup 1)))])
 
+(define_subst "alu2c_zext_subst"
+  [(set (match_operand:EQD 0)
+	(ALUOP2:EQD (zero_extend:EQD (match_operand:EQD 1))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (match_dup 0)
+	(ALUOP2:EQD (match_dup 1)))])
+
 (define_subst "bitalu_zext_subst"
   [(set (match_operand:EQD 0)
 	(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1))
@@ -179,3 +191,232 @@ (define_subst "alu3_zext_op2_subst"
   [(set (match_dup 0)
 	(ALUOP3:EQD (zero_extend:EQD (match_dup 1))
 		    (match_dup 2)))])
+
+;; ADD/SUB with carry set
+(define_subst "addsub3_zext_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(PLUSMINUS3:EQD
+	  (zero_extend:EQD
+	    (match_operand:EQD 1 "" ""))
+	  (zero_extend:EQD
+	    (match_operand:EQD 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (reg:CC_C CARRY_REGNUM)
+	(compare:CC_C
+	  (PLUSMINUS3:EQD
+	    (match_dup 1)
+	    (match_dup 2))
+	  (match_dup 1)))
+   (set (match_dup 0)
+	(PLUSMINUS3:EQD
+	  (match_dup 1)
+	  (match_dup 2)))])
+
+(define_subst "addsub3_zext_op1_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(PLUSMINUS3:EQD
+	  (zero_extend:EQD (match_operand:EQD 1 "" ""))
+	  (zero_extend:EQD (match_operand:EQS1 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (reg:CC_C CARRY_REGNUM)
+	(compare:CC_C
+	  (PLUSMINUS3:EQD
+	    (match_dup 1)
+	    (zero_extend:EQD (match_dup 2)))
+	  (match_dup 1)))
+   (set (match_dup 0)
+	(PLUSMINUS3:EQD
+	  (match_dup 1)
+	  (zero_extend:EQD (match_dup 2))))])
+
+(define_subst "addsub3_zext_op2_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(PLUSMINUS3:EQD
+	  (zero_extend:EQD (match_operand:EQS0 1 "" ""))
+	  (zero_extend:EQD (match_operand:EQD 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (reg:CC_C CARRY_REGNUM)
+	(compare:CC_C
+	  (PLUSMINUS3:EQD
+	    (zero_extend:EQD (match_dup 1))
+	    (match_dup 2))
+	  (zero_extend:EQD (match_dup 1))))
+   (set (match_dup 0)
+	(PLUSMINUS3:EQD
+	  (zero_extend:EQD (match_dup 1))
+	  (match_dup 2)))])
+
+;; ALU variants with carry clobber (they are same for add and sub patterns).
+(define_subst "alucc3_zext_op1_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1 "" ""))
+		    (zero_extend:EQD (match_operand:EQS1 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (match_dup 0)
+	(ALUOP3:EQD (match_dup 1)
+		    (zero_extend:EQD (match_dup 2))))
+   (clobber (reg:CC_C CARRY_REGNUM))])
+
+(define_subst "alucc3_zext_op2_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(ALUOP3:EQD (zero_extend:EQD (match_operand:EQS0 1 "" ""))
+		    (zero_extend:EQD (match_operand:EQD 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (match_dup 0)
+	(ALUOP3:EQD (zero_extend:EQD (match_dup 1))
+		    (match_dup 2)))
+   (clobber (reg:CC_C CARRY_REGNUM))])
+
+(define_subst "alucc3_zext_subst"
+  [(set (match_operand:EQD 0 "" "")
+	(ALUOP3:EQD (zero_extend:EQD (match_operand:EQD 1 "" ""))
+		    (zero_extend:EQD (match_operand:EQD 2 "" ""))))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  ""
+  [(set (match_dup 0)
+	(ALUOP3:EQD (match_dup 1)
+		    (match_dup 2)))
+   (clobber (reg:CC_C CARRY_REGNUM))])
+
+;; Unfortunately define_subst cannot work on splits.  So we are forced to
+;; define all four zero_extension combinations explicitly.
+(define_insn_and_split "add_prereload_temporary_<EQD:mode><EQS0:mode><EQS1:mode>_z1_z2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r,r")
+	(plus:EQD
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "register_operand" "%r,r,r"))
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "reg_or_m255p255_operand" "r,<EQS1:ubyte_constr>,M"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (plus:EQD (zero_extend:EQD (match_dup 1))
+		     (zero_extend:EQD (match_dup 2))))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "add_prereload_temporary_<EQD:mode><EQS1:mode>_noz1_z2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r,r")
+	(plus:EQD
+	  (match_operand:EQD 1 "register_operand" "%r,r,r")
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "reg_or_m255p255_operand" "r,<EQS1:ubyte_constr>,M"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (plus:EQD (match_dup 1)
+		     (zero_extend:EQD (match_dup 2))))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "add_prereload_temporary_<EQD:mode><EQS0:mode>_z1_noz2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r,r")
+	(plus:EQD
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "register_operand" "%r,r,r"))
+	  (match_operand:EQD 2 "reg_or_m255p255_operand" "r,<EQD:ubyte_constr>,M")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (plus:EQD (zero_extend:EQD (match_dup 1))
+		     (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "add_prereload_temporary_<EQD:mode>_noz1_noz2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r,r")
+	(plus:EQD
+	  (match_operand:EQD 1 "register_operand" "%r,r,r")
+	  (match_operand:EQD 2 "reg_or_m255p255_operand" "r,<EQD:ubyte_constr>,M")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (plus:EQD (match_dup 1)
+		     (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "sub_prereload_temporary_<EQD:mode><EQS0:mode><EQS1:mode>_z1_z2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r")
+	(minus:EQD
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "reg_or_ubyte_operand" "r,<EQS0:ubyte_constr>"))
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "register_operand" "r,r"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (minus:EQD (zero_extend:EQD (match_dup 1))
+		      (zero_extend:EQD (match_dup 2))))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "sub_prereload_temporary_<EQD:mode><EQS1:mode>_noz1_z2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r")
+	(minus:EQD
+	  (match_operand:EQD 1 "reg_or_ubyte_operand" "r,<EQD:ubyte_constr>")
+	  (zero_extend:EQD
+	    (match_operand:EQS1 2 "register_operand" "r,r"))))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (minus:EQD (match_dup 1)
+		      (zero_extend:EQD (match_dup 2))))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "sub_prereload_temporary_<EQD:mode><EQS0:mode>_z1_noz2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r")
+	(minus:EQD
+	  (zero_extend:EQD
+	    (match_operand:EQS0 1 "reg_or_ubyte_operand" "r,<EQS0:ubyte_constr>"))
+	  (match_operand:EQD 2 "register_operand" "r,r")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (minus:EQD (zero_extend:EQD (match_dup 1))
+		      (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "sub_prereload_temporary_<EQD:mode>_noz1_noz2"
+  [(set (match_operand:EQD 0 "register_operand" "=r,r")
+	(minus:EQD
+	  (match_operand:EQD 1 "reg_or_ubyte_operand" "r,<EQD:ubyte_constr>")
+	  (match_operand:EQD 2 "register_operand" "r,r")))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (minus:EQD (match_dup 1)
+		      (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "type" "alu")])
diff --git a/gcc/config/pru/constraints.md b/gcc/config/pru/constraints.md
index ad8192b3d2a..98a20dbbd10 100644
--- a/gcc/config/pru/constraints.md
+++ b/gcc/config/pru/constraints.md
@@ -38,6 +38,7 @@
 ;;  N: -32768 to 32767 (16-bit signed integer).
 ;;  O: -128 to 127 (8-bit signed integer).
 ;;  P: 1
+;;  t: CC register
 
 ;; Register constraints.
 
@@ -57,6 +58,10 @@ (define_register_constraint "Rms1" "MULSRC1_REGS"
   "@internal
   The multiply source 1 register.")
 
+(define_register_constraint "Rcry" "CARRY_REGS"
+  "@internal
+  The internal CARRY register.")
+
 ;; Integer constraints.
 
 (define_constraint "I"
diff --git a/gcc/config/pru/predicates.md b/gcc/config/pru/predicates.md
index 1eb95d0f96c..113b5f73873 100644
--- a/gcc/config/pru/predicates.md
+++ b/gcc/config/pru/predicates.md
@@ -30,6 +30,14 @@ (define_predicate "const_ubyte_operand"
   return IN_RANGE (INTVAL (op) & GET_MODE_MASK (mode), 0, 0xff);
 })
 
+(define_predicate "const_m255p255_operand"
+  (match_code "const_int")
+{
+  gcc_assert (mode != VOIDmode);
+  return IN_RANGE (INTVAL (op) & GET_MODE_MASK (mode), 0, 0xff)
+	 || IN_RANGE (-INTVAL (op) & GET_MODE_MASK (mode), 0, 0xff);
+})
+
 (define_predicate "const_uhword_operand"
   (match_code "const_int")
 {
@@ -129,6 +137,10 @@ (define_predicate "reg_or_ubyte_operand"
   (ior (match_operand 0 "const_ubyte_operand")
        (match_operand 0 "register_operand")))
 
+(define_predicate "reg_or_m255p255_operand"
+  (ior (match_operand 0 "const_m255p255_operand")
+       (match_operand 0 "register_operand")))
+
 (define_predicate "reg_or_const_1_operand"
   (ior (match_operand 0 "const_1_operand")
        (match_operand 0 "register_operand")))
diff --git a/gcc/config/pru/pru-modes.def b/gcc/config/pru/pru-modes.def
new file mode 100644
index 00000000000..7a692e9b9be
--- /dev/null
+++ b/gcc/config/pru/pru-modes.def
@@ -0,0 +1,21 @@
+/* Machine description for PRU architecture.
+   Copyright (C) 2019 Free Software Foundation, Inc.
+   Contributed by Dimitar Dimitrov.
+
+   This file is part of GCC.
+
+   GCC is free software; you can redistribute it and/or modify it
+   under the terms of the GNU General Public License as published by
+   the Free Software Foundation; either version 3, or (at your option)
+   any later version.
+
+   GCC is distributed in the hope that it will be useful, but
+   WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU General Public License
+   along with GCC; see the file COPYING3.  If not see
+   <http://www.gnu.org/licenses/>.  */
+
+CC_MODE (CC_C);     /* C represents unsigned overflow of a simple addition.  */
diff --git a/gcc/config/pru/pru-protos.h b/gcc/config/pru/pru-protos.h
index 6610ac91a37..ad95855f918 100644
--- a/gcc/config/pru/pru-protos.h
+++ b/gcc/config/pru/pru-protos.h
@@ -40,6 +40,8 @@ void pru_register_pragmas (void);
 extern rtx pru_get_return_address (int);
 extern int pru_hard_regno_rename_ok (unsigned int, unsigned int);
 
+extern void pru_decompose_di_binop (rtx, rtx, rtx *, rtx *, rtx *, rtx *);
+
 extern const char *pru_output_sign_extend (rtx *);
 extern const char *pru_output_signed_cbranch (rtx *, bool);
 extern const char *pru_output_signed_cbranch_ubyteop2 (rtx *, bool);
diff --git a/gcc/config/pru/pru.c b/gcc/config/pru/pru.c
index a715f6b07ce..afd627efb76 100644
--- a/gcc/config/pru/pru.c
+++ b/gcc/config/pru/pru.c
@@ -154,20 +154,41 @@ pru_compute_frame_layout (void)
   cfun->machine->save_regs_offset = out_args_size + var_size;
 }
 
+static rtx
+gen_addsi3_impl_cclob (rtx op0, rtx op1, rtx op2)
+{
+  return gen_add_implsisisi__ccnoz_ccz1_ccz2_csz1_csz2_csz (op0, op1, op2);
+}
+
+static rtx
+gen_subsi3_impl_cclob (rtx op0, rtx op1, rtx op2)
+{
+  return gen_sub_implsisisi__ccnoz_ccz1_ccz2_csz1_csz2_csz (op0, op1, op2);
+}
+
 /* Emit efficient RTL equivalent of ADD3 with the given const_int for
    frame-related registers.
      op0	  - Destination register.
      op1	  - First addendum operand (a register).
      addendum	  - Second addendum operand (a constant).
      kind	  - Note kind.  REG_NOTE_MAX if no note must be added.
+
+    We cannot use gen_addsi3_insn because try_split refuses to split
+    RTX_FRAME_RELATED_P insns.  Instead we instantiate PRU variants
+    directly.
  */
 static rtx
 pru_add3_frame_adjust (rtx op0, rtx op1, int addendum,
 		       const enum reg_note kind)
 {
+  rtx op0_adjust_dwarf;
+  rtx op0_adjust;
   rtx insn;
 
-  rtx op0_adjust = gen_rtx_SET (op0, plus_constant (Pmode, op1, addendum));
+  /* DWARF parser cannot handle PRU's carry,
+     so feed it a simplified expression.  */
+  op0_adjust_dwarf = gen_rtx_SET (op0, plus_constant (Pmode, op1, addendum));
+  op0_adjust = gen_addsi3_impl_cclob (op0, op1, GEN_INT (addendum));
 
   if (UBYTE_INT (addendum) || UBYTE_INT (-addendum))
     insn = emit_insn (op0_adjust);
@@ -181,18 +202,18 @@ pru_add3_frame_adjust (rtx op0, rtx op1, int addendum,
       if (addendum < 0)
 	{
 	  emit_insn (gen_rtx_SET (tmpreg, gen_int_mode (-addendum, Pmode)));
-	  insn = emit_insn (gen_sub3_insn (op0, op1, tmpreg));
+	  insn = emit_insn (gen_subsi3_impl_cclob (op0, op1, tmpreg));
 	}
       else
 	{
 	  emit_insn (gen_rtx_SET (tmpreg, gen_int_mode (addendum, Pmode)));
-	  insn = emit_insn (gen_add3_insn (op0, op1, tmpreg));
+	  insn = emit_insn (gen_addsi3_impl_cclob (op0, op1, tmpreg));
 	}
     }
 
   /* Attach a note indicating what happened.  */
   if (kind != REG_NOTE_MAX)
-    add_reg_note (insn, kind, copy_rtx (op0_adjust));
+    add_reg_note (insn, kind, copy_rtx (op0_adjust_dwarf));
 
   RTX_FRAME_RELATED_P (insn) = 1;
 
@@ -513,6 +534,16 @@ pru_can_use_return_insn (void)
   return cfun->machine->total_size == 0;
 }
 
+/* Implement TARGET_FIXED_CONDITION_CODE_REGS.  */
+static bool
+pru_fixed_condition_code_regs (unsigned int *p1, unsigned int *p2)
+{
+
+  *p1 = CARRY_REGNUM;
+  *p2 = INVALID_REGNUM;
+  return true;
+}
+
 /* Implement TARGET_HARD_REGNO_MODE_OK.  */
 
 static bool
@@ -629,6 +660,18 @@ pru_option_override (void)
   pru_register_abicheck_pass ();
 }
 
+/* Calculate mode-dependent factor for RTX cost.  PRU ALU is 32 bit,
+   despite GCC's UNITS_PER_WORD=1.  Hence optimize for SImode.  */
+static int pru_mode_factor (machine_mode mode)
+{
+  int size = GET_MODE_SIZE (mode);
+
+  if (size <= 0)
+    size = 1;
+
+  return CEIL (size, GET_MODE_SIZE (SImode));
+}
+
 /* Compute a (partial) cost for rtx X.  Return true if the complete
    cost has been computed, and false if subexpressions should be
    scanned.  In either case, *TOTAL contains the cost result.  */
@@ -685,16 +728,11 @@ pru_rtx_costs (rtx x, machine_mode mode,
       }
     case SET:
       {
-	int factor;
-
 	/* A SET doesn't have a mode, so let's look at the SET_DEST to get
 	   the mode for the factor.  */
 	mode = GET_MODE (SET_DEST (x));
 
-	/* SI move has the same cost as a QI move.  Moves larger than
-	   64 bits are costly.  */
-	factor = CEIL (GET_MODE_SIZE (mode), GET_MODE_SIZE (SImode));
-	*total = factor * COSTS_N_INSNS (1);
+	*total = pru_mode_factor (mode) * COSTS_N_INSNS (1);
 
 	return false;
       }
@@ -703,7 +741,7 @@ pru_rtx_costs (rtx x, machine_mode mode,
       {
 	/* Factor in that "mul" requires fixed registers, which
 	   would likely require register moves.  */
-	*total = COSTS_N_INSNS (7);
+	*total = pru_mode_factor (mode) * COSTS_N_INSNS (7);
 	return false;
       }
     case PLUS:
@@ -729,30 +767,41 @@ pru_rtx_costs (rtx x, machine_mode mode,
 	  }
 	else
 	  {
-	    *total = COSTS_N_INSNS (1);
+	    *total = pru_mode_factor (mode) * COSTS_N_INSNS (1);
 	    return false;
 	  }
 	}
     case SIGN_EXTEND:
       {
-	*total = COSTS_N_INSNS (3);
+	*total = pru_mode_factor (mode) * COSTS_N_INSNS (3);
 	return false;
       }
     case ASHIFTRT:
       {
 	rtx op1 = XEXP (x, 1);
 	if (const_1_operand (op1, VOIDmode))
-	  *total = COSTS_N_INSNS (3);
+	  *total = pru_mode_factor (mode) * COSTS_N_INSNS (3);
 	else
-	  *total = COSTS_N_INSNS (7);
+	  *total = pru_mode_factor (mode) * COSTS_N_INSNS (7);
 	return false;
       }
     case ZERO_EXTRACT:
       {
+	rtx op0 = XEXP (x, 0);
+	rtx op1 = XEXP (x, 1);
 	rtx op2 = XEXP (x, 2);
+	machine_mode op2_mode = GET_MODE (op2);
+
+	/* Since op2 integer range is 0..31, we can safely
+	   assign OP0 mode to satisfy the constraint.  */
+	if (op2_mode == VOIDmode)
+	  op2_mode = GET_MODE (op0);
+
 	if ((outer_code == EQ || outer_code == NE)
-	    && CONST_INT_P (op2)
-	    && INTVAL (op2) == 1)
+	    && REG_P (op0)
+	    && CONST_INT_P (op1)
+	    && INTVAL (op1) == 1
+	    && reg_or_ubyte_operand (op2, op2_mode))
 	  {
 	    /* Branch if bit is set/clear is a single instruction.  */
 	    *total = COSTS_N_INSNS (0);
@@ -760,7 +809,7 @@ pru_rtx_costs (rtx x, machine_mode mode,
 	  }
 	else
 	  {
-	    *total = COSTS_N_INSNS (2);
+	    *total = pru_mode_factor (mode) * COSTS_N_INSNS (2);
 	    return false;
 	  }
       }
@@ -772,9 +821,7 @@ pru_rtx_costs (rtx x, machine_mode mode,
 
     default:
       {
-	/* PRU ALU is 32 bit, despite GCC's UNITS_PER_WORD=1.  */
-	int factor = CEIL (GET_MODE_SIZE (mode), GET_MODE_SIZE (SImode));
-	*total = factor * COSTS_N_INSNS (1);
+	*total = pru_mode_factor (mode) * COSTS_N_INSNS (1);
 	return false;
       }
     }
@@ -961,6 +1008,24 @@ pru_expand_fp_compare (rtx comparison, machine_mode mode)
   return gen_rtx_fmt_ee (jump_code, mode, cmp, const0_rtx);
 }
 
+/* Decompose operands for a 64-bit binary operation in OP1 and OP2
+   into its component 32-bit subregs.  OP2 may be an immediate
+   constant and we want to simplify it in that case.
+   Based on arm_decompose_di_binop.  */
+void
+pru_decompose_di_binop (rtx op1, rtx op2, rtx *lo_op1, rtx *hi_op1,
+			rtx *lo_op2, rtx *hi_op2)
+{
+  *lo_op1 = simplify_gen_subreg (SImode, op1, DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  *hi_op1 = simplify_gen_subreg (SImode, op1, DImode,
+				 subreg_highpart_offset (SImode, DImode));
+  *lo_op2 = simplify_gen_subreg (SImode, op2, DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  *hi_op2 = simplify_gen_subreg (SImode, op2, DImode,
+				 subreg_highpart_offset (SImode, DImode));
+}
+
 /* Return the sign bit position for given OP's mode.  */
 static int
 sign_bit_position (const rtx op)
@@ -1655,6 +1720,7 @@ pru_print_operand (FILE *file, rtx op, int letter)
 	    }
 	  if (REGNO (op) % 4 != 0)
 	    {
+		print_rtl(stdout, op);
 	      output_operand_lossage ("non 32 bit register operand for '%%%c'",
 				      letter);
 	      return;
@@ -2514,6 +2580,8 @@ pru_reorg_loop (rtx_insn *insns)
     if (INSN_P (insn))
       switch (recog_memoized (insn))
 	{
+	case CODE_FOR_doloop_begin_internalhi_cc_clobber:
+	case CODE_FOR_doloop_begin_internalsi_cc_clobber:
 	case CODE_FOR_doloop_begin_internalhi:
 	case CODE_FOR_doloop_begin_internalsi:
 	  insn_extract (insn);
@@ -2529,6 +2597,8 @@ pru_reorg_loop (rtx_insn *insns)
 	  loop->begin = begin;
 	  break;
 
+	case CODE_FOR_doloop_end_internalhi_cc_clobber:
+	case CODE_FOR_doloop_end_internalsi_cc_clobber:
 	case CODE_FOR_doloop_end_internalhi:
 	case CODE_FOR_doloop_end_internalsi:
 	  insn_extract (insn);
@@ -2899,6 +2969,9 @@ pru_unwind_word_mode (void)
 #undef TARGET_CAN_ELIMINATE
 #define TARGET_CAN_ELIMINATE pru_can_eliminate
 
+#undef TARGET_FIXED_CONDITION_CODE_REGS
+#define TARGET_FIXED_CONDITION_CODE_REGS pru_fixed_condition_code_regs
+
 #undef TARGET_HARD_REGNO_MODE_OK
 #define TARGET_HARD_REGNO_MODE_OK pru_hard_regno_mode_ok
 
diff --git a/gcc/config/pru/pru.h b/gcc/config/pru/pru.h
index 314e877a5f9..88c9d9e3264 100644
--- a/gcc/config/pru/pru.h
+++ b/gcc/config/pru/pru.h
@@ -135,12 +135,13 @@
    31     r31		  Special I/O register.  Not used by compiler.
 
    32     loop_cntr	  Internal register used as a counter by LOOP insns.
+   33     cc		  Virtual register number for GCC uses.
 
-   33     pc		  Not an actual register.
+   34     pc		  Not an actual register.
 
-   34     fake_fp	  Fake Frame Pointer (always eliminated).
-   35     fake_ap	  Fake Argument Pointer (always eliminated).
-   36			  First Pseudo Register.
+   35     fake_fp	  Fake Frame Pointer (always eliminated).
+   36     fake_ap	  Fake Argument Pointer (always eliminated).
+   37			  First Pseudo Register.
 
    The definitions for some hard register numbers are located in pru.md.
    Note that GCC's internal register numbering differs from the conventional
@@ -161,7 +162,8 @@
 /*  20 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,	\
 /*  24 */  0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0,	\
 /*  28 */  0,0,0,0, 0,0,0,0, 1,1,1,1, 1,1,1,1,	\
-/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1	\
+/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,	\
+/*  36 */  1,1,1,1				\
   }
 
 /* Call used == caller saved + fixed regs + args + ret vals.  */
@@ -175,7 +177,8 @@
 /*  20 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,	\
 /*  24 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,	\
 /*  28 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,	\
-/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1	\
+/*  32 */  1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1,	\
+/*  36 */  1,1,1,1				\
   }
 
 #define PRU_SEQ_R(X)  (X) * 4 + 0, (X) * 4 + 1, (X) * 4 + 2, (X) * 4 + 3
@@ -202,7 +205,7 @@
 									    \
     /* I/O and virtual registers.  */					    \
     PRU_SEQ_R (30), PRU_SEQ_R (31), PRU_SEQ_R (32), PRU_SEQ_R (33),	    \
-    PRU_SEQ_R (34), PRU_SEQ_R (35)					    \
+    PRU_SEQ_R (34), PRU_SEQ_R (35), PRU_SEQ_R (36)			    \
   }
 
 /* Register Classes.  */
@@ -215,6 +218,7 @@ enum reg_class
   MULDST_REGS,
   MULSRC0_REGS,
   MULSRC1_REGS,
+  CARRY_REGS,
   GP_REGS,
   ALL_REGS,
   LIM_REG_CLASSES
@@ -229,6 +233,7 @@ enum reg_class
      "MULDST_REGS",	  \
      "MULSRC0_REGS",	  \
      "MULSRC1_REGS",	  \
+     "CARRY_REGS",	  \
      "GP_REGS",		  \
      "ALL_REGS" }
 
@@ -242,6 +247,7 @@ enum reg_class
     /* MULDST_REGS    */ { 0, 0, 0, 0x00000f00, 0},		\
     /* MULSRC0_REGS   */ { 0, 0, 0, 0x000f0000, 0},		\
     /* MULSRC1_REGS   */ { 0, 0, 0, 0x00f00000, 0},		\
+    /* CARRY_REGS     */ { 0, 0, 0, 0, 0x000000f0},		\
     /* GP_REGS	      */ { ~0, ~0, ~0, ~0, 0},			\
     /* ALL_REGS	      */ { ~0,~0, ~0, ~0, ~0}			\
   }
@@ -252,6 +258,7 @@ enum reg_class
 	((REGNO) == MULDST_REGNUM ? MULDST_REGS				    \
 	 : (REGNO) == MULSRC0_REGNUM ? MULSRC0_REGS			    \
 	 : (REGNO) == MULSRC1_REGNUM ? MULSRC1_REGS			    \
+	 : (REGNO) == CARRY_REGNUM ? CARRY_REGS				    \
 	 : (REGNO) >= FIRST_ARG_REGNUM					    \
 	    && (REGNO) <= LAST_ARG_REGNUM ? SIB_REGS			    \
 	 : (REGNO) == STATIC_CHAIN_REGNUM ? SIB_REGS			    \
@@ -418,6 +425,7 @@ typedef struct pru_args
     PRU_NAME_R ("r30"),		  \
     PRU_NAME_R ("r31"),		  \
     PRU_NAME_R ("loopcntr_reg"),  \
+    PRU_NAME_R ("cc"),		  \
     PRU_NAME_R ("pc"),		  \
     PRU_NAME_R ("fake_fp"),	  \
     PRU_NAME_R ("fake_ap"),	  \
diff --git a/gcc/config/pru/pru.md b/gcc/config/pru/pru.md
index 2f1bc21f025..a675dea7d71 100644
--- a/gcc/config/pru/pru.md
+++ b/gcc/config/pru/pru.md
@@ -26,9 +26,9 @@ (define_constants
    (LAST_ARG_REGNUM		119) ;
    (FIRST_RETVAL_REGNUM		56) ; Return value registers.
    (LAST_RETVAL_REGNUM		60) ;
-   (FIRST_CALLEE_SAVED_REGNUM	12) ; Callee saved registers.
+   (FIRST_CALLEE_SAVED_REGNUM	14) ; Callee saved registers.
    (LAST_CALEE_SAVED_REGNUM	55) ;
-   (PROLOGUE_TEMP_REGNUM	4) ; Temporary register to use in prologue.
+   (PROLOGUE_TEMP_REGNUM	4)  ; Temporary register to use in prologue.
 
    (RA_REGNUM			14) ; Return address register r3.w2.
    (FP_REGNUM			16) ; Frame pointer register.
@@ -37,15 +37,16 @@ (define_constants
    (MULSRC1_REGNUM		116) ; Multiply source register.
    (LAST_NONIO_GP_REGNUM	119) ; Last non-I/O general purpose register.
    (LOOPCNTR_REGNUM		128) ; internal LOOP counter register
-   (LAST_GP_REGNUM		132) ; Last general purpose register.
+   (CARRY_REGNUM		132) ; Carry flag.
+   (LAST_GP_REGNUM		136) ; Last general purpose register.
 
    ;; Target register definitions.
    (STACK_POINTER_REGNUM	8)
    (HARD_FRAME_POINTER_REGNUM	FP_REGNUM)
-   (PC_REGNUM			132)
-   (FRAME_POINTER_REGNUM	136)
-   (ARG_POINTER_REGNUM		140)
-   (FIRST_PSEUDO_REGISTER	144)
+   (PC_REGNUM			136)
+   (FRAME_POINTER_REGNUM	140)
+   (ARG_POINTER_REGNUM		144)
+   (FIRST_PSEUDO_REGISTER	148)
   ]
 )
 
@@ -93,6 +94,7 @@ (define_mode_iterator MOV8_16 [QI QQ UQQ
 (define_mode_iterator MOV32 [SI SQ USQ SA USA SF SD])
 (define_mode_iterator MOV64 [DI DF DD DQ UDQ])
 (define_mode_iterator QISI [QI HI SI])
+(define_mode_iterator QIDI [QI HI SI DI])
 (define_mode_iterator HISI [HI SI])
 (define_mode_iterator SFDF [SF DF])
 
@@ -126,7 +128,7 @@ (define_expand "mov<mode>"
   /* It helps to split constant loading and memory access
      early, so that the LDI/LDI32 instructions can be hoisted
      outside a loop body.  */
-  if (MEM_P (operands[0]))
+  if (MEM_P (operands[0]) && can_create_pseudo_p ())
     operands[1] = force_reg (<MODE>mode, operands[1]);
 })
 
@@ -175,7 +177,10 @@ (define_insn "prumov<mode>"
 ; GCC expects to be able to move registers around "no matter what".
 ; Forcing DI reg alignment (akin to microblaze's HARD_REGNO_MODE_OK)
 ; does not seem efficient, and will violate TI ABI.
-(define_insn "mov<mode>"
+;
+; DI memory access is already efficient, so do not split it.  But do
+; split other moves.
+(define_insn_and_split "mov<mode>"
   [(set (match_operand:MOV64 0 "nonimmediate_operand" "=m,r,r,r,r,r")
 	(match_operand:MOV64 1 "general_operand"      "r,m,r,T,J,nF"))]
   ""
@@ -203,11 +208,46 @@ (define_insn "mov<mode>"
     default:
       gcc_unreachable ();
   }
+}
+  "&& !MEM_P (operands[0]) && !MEM_P (operands[1])"
+  [(set (match_dup 2) (match_dup 3))
+   (set (match_dup 4) (match_dup 5))]
+{
+  unsigned int low_off = subreg_lowpart_offset (SImode, DImode);
+  unsigned int high_off = subreg_highpart_offset (SImode, DImode);
+  rtx lo_half[2], hi_half[2];
+  int num;
+
+  for (num = 0; num < 2; num++)
+    {
+      rtx op = operands[num];
+
+      lo_half[num] = simplify_gen_subreg (SImode, op,
+					  GET_MODE (op) == VOIDmode
+					  ? DImode : GET_MODE (op), low_off);
+      hi_half[num] = simplify_gen_subreg (SImode, op,
+					  GET_MODE (op) == VOIDmode
+					  ? DImode : GET_MODE (op), high_off);
+    }
+
+  if (reg_overlap_mentioned_p (lo_half[0], hi_half[1]))
+    {
+      operands[2] = hi_half[0];
+      operands[3] = hi_half[1];
+      operands[4] = lo_half[0];
+      operands[5] = lo_half[1];
+    }
+  else
+    {
+      operands[2] = lo_half[0];
+      operands[3] = lo_half[1];
+      operands[4] = hi_half[0];
+      operands[5] = hi_half[1];
+    }
 }
   [(set_attr "type" "st,ld,alu,alu,alu,alu")
    (set_attr "length" "4,4,8,8,8,16")])
 
-;
 ; load_multiple pattern(s).
 ;
 ; ??? Due to reload problems with replacing registers inside match_parallel
@@ -346,6 +386,26 @@ (define_insn "*zero_extend<EQS0:mode><EQD:mode>2"
   "mov\\t%0, %1"
   [(set_attr "type"     "alu")])
 
+(define_expand "zero_extend<mode>di2"
+  [(set (match_operand:DI 0 "register_operand")
+	(zero_extend:DI (match_operand:QISI 1 "register_operand")))]
+  ""
+{
+  unsigned int low_off = subreg_lowpart_offset (SImode, DImode);
+  unsigned int high_off = subreg_highpart_offset (SImode, DImode);
+  rtx dst_low = simplify_gen_subreg (SImode, operands[0], DImode, low_off);
+  rtx dst_high = simplify_gen_subreg (SImode, operands[0], DImode, high_off);
+  rtx src = operands[1];
+
+  if (<MODE>mode == SImode)
+    emit_move_insn (dst_low, src);
+  else
+    emit_insn (gen_zero_extend<mode>si2 (dst_low, src));
+  emit_move_insn (dst_high, GEN_INT (0));
+
+  DONE;
+})
+
 ;; Sign extension patterns.  We have to emulate them due to lack of
 ;; signed operations in PRU's ALU.
 
@@ -380,50 +440,281 @@ (define_insn "extzv<mode>"
 
 ;; Arithmetic Operations
 
-(define_expand "add<mode>3"
-  [(set (match_operand:QISI 0 "register_operand")
-	(plus:QISI (match_operand:QISI 1 "register_operand")
-		 (match_operand:QISI 2 "nonmemory_operand")))]
+(define_insn_and_split "add<mode>3"
+  [(set (match_operand:QISI 0 "register_operand" "=r,r,r")
+	(plus:QISI (match_operand:QISI 1 "register_operand" "%r,r,r")
+		   (match_operand:QISI 2 "reg_or_m255p255_operand" "r,<QISI:ubyte_constr>,M")))]
   ""
-  "")
-
-(define_insn "adddi3"
-  [(set (match_operand:DI 0 "register_operand"		    "=&r,&r,&r")
-	(plus:DI (match_operand:DI 1 "register_operand"	    "%r,r,r")
-		 (match_operand:DI 2 "reg_or_ubyte_operand" "r,I,M")))]
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (plus:QISI (match_dup 1) (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
   ""
+  [(set_attr "type" "alu")])
+
+(define_insn "add<mode>3_carryset"
+  [(set (reg:CC_C CARRY_REGNUM)
+	  (compare:CC_C
+	    (plus:QISI
+	      (match_operand:QISI 1 "register_operand" "%r,r")
+	      (match_operand:QISI 2 "reg_or_ubyte_operand" "r,<QISI:ubyte_constr>"))
+	    (match_dup 1)))
+   (set (match_operand:QISI 0 "register_operand" "=r,r")
+	(plus:QISI
+	  (match_dup 1)
+	  (match_dup 2)))]
+  "reload_completed"
+  "@
+   add\\t%0, %1, %2
+   add\\t%0, %1, %u2"
+  [(set_attr "type" "alu")])
+
+(define_insn "add<mode>3_carryin"
+  [(set (reg:CC_C CARRY_REGNUM)
+	(ior:CC_C
+	  (compare:CC_C
+	    (plus:QISI
+	      (match_operand:QISI 1 "register_operand" "%r,r")
+	      (plus:QISI
+		(match_operand:QISI 2 "reg_or_ubyte_operand" "r,<QISI:ubyte_constr>")
+		(ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))
+	    (match_dup 1))
+	  (compare:CC_C
+	    (plus:QISI
+	      (match_dup 1)
+	      (plus:QISI
+		(match_dup 2)
+		(ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))
+	    (match_dup 2))))
+   (set (match_operand:QISI 0 "register_operand" "=r,r")
+	(plus:QISI
+	  (match_dup 1)
+	  (plus:QISI
+	    (match_dup 2)
+	    (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))))]
+  "reload_completed"
   "@
-   add\\t%F0, %F1, %F2\;adc\\t%N0, %N1, %N2
-   add\\t%F0, %F1, %2\;adc\\t%N0, %N1, 0
-   sub\\t%F0, %F1, %n2\;suc\\t%N0, %N1, 0"
+   adc\\t%0, %1, %2
+   adc\\t%0, %1, %2"
+  [(set_attr "type" "alu")])
+
+(define_insn "add0<mode>3_carryin"
+  [(set (reg:CC_C CARRY_REGNUM)
+	(ior:CC_C
+	  (compare:CC_C
+	    (plus:QISI
+	      (match_operand:QISI 1 "register_operand" "r")
+	      (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))
+	    (match_dup 1))
+	  (compare:CC_C
+	    (plus:QISI
+	      (match_dup 1)
+	      (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))
+	    (const_int 0))))
+   (set (match_operand:QISI 0 "register_operand" "=r")
+	(plus:QISI
+	  (match_dup 1)
+	  (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))]
+  "reload_completed"
+  "adc\\t%0, %1, 0"
+  [(set_attr "type" "alu")])
+
+;; We cannot split at expand phase, as most arm variants do:
+;;     https://gcc.gnu.org/ml/gcc-patches/2019-10/msg01379.html
+;; PRU takes the approach of PDP11 backend and hides CC mode until LRA
+;; has finished.  A large complication for PRU is that all add instructions
+;; set the carry flag.  This makes it rather difficult to expose CC_CARRY
+;; early at expand, since we cannot implement addptr.
+(define_insn_and_split "adddi3"
+  [(set (match_operand:DI          0 "register_operand"		"=&r,r")
+	(plus:DI (match_operand:DI 1 "register_operand"		"%r,r")
+		 (match_operand:DI 2 "reg_or_m255p255_operand"	"r,IM")))]
+  ""
+  "#"
+  "reload_completed"
+  [(const_int 0)]
+{
+  rtx lo_dest, hi_dest;
+  rtx lo_op1, hi_op1, lo_op2, hi_op2;
+  pru_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,
+			  &lo_op2, &hi_op2);
+  lo_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  hi_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_highpart_offset (SImode, DImode));
+
+  gcc_assert (!reg_overlap_mentioned_p (lo_dest, hi_op1)
+	      && !reg_overlap_mentioned_p (lo_dest, hi_op2));
+
+  if (const_int_operand (operands[2], DImode) && INTVAL (operands[2]) < 0)
+    {
+      rtx op2_abs = GEN_INT (-INTVAL (operands[2]));
+      emit_insn (gen_subsi3_carryset (lo_dest, lo_op1, op2_abs));
+      emit_insn (gen_sub0si3_carryin (hi_dest, hi_op1));
+    }
+  else if (lo_op2 == const0_rtx)
+    {
+      if (lo_dest != lo_op1)
+	emit_move_insn (lo_dest, lo_op1);
+      /* Assume hi_op2 won't also be zero.  */
+      emit_insn (gen_addsi3 (hi_dest, hi_op1, hi_op2));
+    }
+  else
+    {
+      gcc_assert (reg_or_ubyte_operand (lo_op2, SImode));
+      gcc_assert (reg_or_ubyte_operand (hi_op2, SImode));
+
+      emit_insn (gen_addsi3_carryset (lo_dest, lo_op1, lo_op2));
+      if (hi_op2 == const0_rtx)
+	emit_insn (gen_add0si3_carryin (hi_dest, hi_op1));
+      else
+	emit_insn (gen_addsi3_carryin (hi_dest, hi_op1, hi_op2));
+    }
+}
   [(set_attr "type" "alu")
    (set_attr "length" "8")])
 
-(define_expand "sub<mode>3"
-  [(set (match_operand:QISI 0 "register_operand")
-	(minus:QISI (match_operand:QISI 1 "reg_or_ubyte_operand")
-		    (match_operand:QISI 2 "reg_or_ubyte_operand")))]
-  ""
-  "")
 
-(define_insn "subdi3"
-  [(set (match_operand:DI 0 "register_operand"		      "=&r,&r")
-	(minus:DI (match_operand:DI 1 "reg_or_ubyte_operand"  "r,I")
-		  (match_operand:DI 2 "register_operand"      "r,r")))]
+(define_insn_and_split "sub<mode>3"
+  [(set (match_operand:QISI 0 "register_operand" "=r")
+	   (minus:QISI
+	     (match_operand:QISI 1 "reg_or_ubyte_operand" "r<QISI:ubyte_constr>")
+	     (match_operand:QISI 2 "register_operand" "r")))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (minus:QISI (match_dup 1) (match_dup 2)))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
   ""
+  [(set_attr "type" "alu")])
+
+(define_insn "sub<mode>3_carryset"
+  [(set (reg:CC_C CARRY_REGNUM)
+	  (compare:CC_C
+	    (minus:QISI
+	      (match_operand:QISI 1 "reg_or_ubyte_operand" "r,<QISI:ubyte_constr>")
+	      (match_operand:QISI 2 "reg_or_ubyte_operand" "r<QISI:ubyte_constr>,r"))
+	    (match_dup 1)))
+   (set (match_operand:QISI 0 "register_operand" "=r,r")
+	(minus:QISI
+	  (match_dup 1)
+	  (match_dup 2)))]
+  "reload_completed"
   "@
-   sub\\t%F0, %F1, %F2\;suc\\t%N0, %N1, %N2
-   rsb\\t%F0, %F2, %1\;rsc\\t%N0, %N2, 0"
+   sub\\t%0, %1, %2
+   rsb\\t%0, %2, %u1"
+  [(set_attr "type" "alu")])
+
+(define_insn "sub<mode>3_carryin"
+  [(set (reg:CC_C CARRY_REGNUM)
+	(ior:CC_C
+	  (compare:CC_C
+	    (minus:QISI
+	      (match_operand:QISI 1 "reg_or_ubyte_operand" "r,<QISI:ubyte_constr>")
+	      (minus:QISI
+		(match_operand:QISI 2 "reg_or_ubyte_operand" "r<QISI:ubyte_constr>,r")
+		(ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))
+	    (match_dup 1))
+	  (compare:CC_C
+	    (minus:QISI
+	      (match_dup 1)
+	      (minus:QISI
+		(match_dup 2)
+		(ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))
+	    (match_dup 2))))
+   (set (match_operand:QISI 0 "register_operand" "=r,r")
+	(minus:QISI
+	  (match_dup 1)
+	  (minus:QISI
+	    (match_dup 2)
+	    (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))))]
+  "reload_completed"
+  "@
+   suc\\t%0, %1, %2
+   rsc\\t%0, %2, %u1"
+  [(set_attr "type" "alu")])
+
+(define_insn "sub0<mode>3_carryin"
+  [(set (reg:CC_C CARRY_REGNUM)
+	(ior:CC_C
+	  (compare:CC_C
+	    (minus:QISI
+	      (match_operand:QISI 1 "register_operand" "r")
+	      (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))
+	    (match_dup 1))
+	  (compare:CC_C
+	    (minus:QISI
+	      (match_dup 1)
+	      (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0)))
+	    (const_int 0))))
+   (set (match_operand:QISI 0 "register_operand" "=r")
+	(minus:QISI
+	  (match_dup 1)
+	  (ne:QISI (reg:CC_C CARRY_REGNUM) (const_int 0))))]
+  "reload_completed"
+  "suc\\t%0, %1, 0"
+  [(set_attr "type" "alu")])
+
+(define_insn_and_split "subdi3"
+  [(set (match_operand:DI	    0 "register_operand"	"=&r")
+	(minus:DI (match_operand:DI 1 "reg_or_ubyte_operand"	"rI")
+		  (match_operand:DI 2 "register_operand"	"r")))]
+  ""
+  "#"
+  "&& reload_completed"
+  [(const_int 0)]
+{
+  rtx lo_dest, hi_dest;
+  rtx lo_op1, hi_op1, lo_op2, hi_op2;
+  pru_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,
+			  &lo_op2, &hi_op2);
+  lo_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  hi_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_highpart_offset (SImode, DImode));
+
+  gcc_assert (!reg_overlap_mentioned_p (lo_dest, hi_op1)
+	      && !reg_overlap_mentioned_p (lo_dest, hi_op2));
+
+  if (lo_op2 == const0_rtx)
+    {
+      if (lo_dest != lo_op1)
+	emit_move_insn (lo_dest, lo_op1);
+      /* Assume hi_op2 won't also be zero.  */
+      emit_insn (gen_subsi3 (hi_dest, hi_op1, hi_op2));
+    }
+  else
+    {
+      gcc_assert (reg_or_ubyte_operand (lo_op2, SImode));
+      gcc_assert (reg_or_ubyte_operand (hi_op2, SImode));
+
+      emit_insn (gen_subsi3_carryset (lo_dest, lo_op1, lo_op2));
+      if (hi_op2 == const0_rtx)
+	emit_insn (gen_sub0si3_carryin (hi_dest, hi_op1));
+      else
+	emit_insn (gen_subsi3_carryin (hi_dest, hi_op1, hi_op2));
+    }
+}
   [(set_attr "type" "alu")
    (set_attr "length" "8")])
+
 
 ;;  Negate and ones complement
 
 (define_expand "neg<mode>2"
-  [(set (match_operand:QISI 0 "register_operand")
-	(neg:QISI (match_operand:QISI 1 "register_operand")))]
+  [(set (match_operand:QIDI 0 "register_operand")
+	(neg:QIDI (match_operand:QIDI 1 "register_operand")))]
   ""
-  "")
+{
+  gcc_assert (!reload_completed);
+
+  emit_insn (gen_sub<mode>3 (operands[0], GEN_INT (0), operands[1]));
+  DONE;
+})
 
 (define_expand "one_cmpl<mode>2"
   [(set (match_operand:QISI 0 "register_operand")
@@ -476,11 +767,13 @@ (define_expand "<shift_op><mode>3"
 ;
 ; Note that the number of shifts is truncated to QImode.  This is a fair
 ; assumption for a loop-based shifting implementation.
+; TODO - expand to use a second register (fill Rtmp; lsl Rtmp, OP2; or Rdst, Rsrc, Rtmp);
+; TODO - remove the CC clobber!
 (define_expand "ashr<mode>3"
   [(set (match_operand:QISI 0 "register_operand")
-	  (ashiftrt:QISI
-	    (match_operand:QISI 1 "register_operand")
-	    (match_operand:QI 2 "reg_or_const_1_operand")))]
+	(ashiftrt:QISI
+	  (match_operand:QISI 1 "register_operand")
+	  (match_operand:QI 2 "reg_or_const_1_operand")))]
   ""
 {
   rtx dst = operands[0];
@@ -490,6 +783,8 @@ (define_expand "ashr<mode>3"
   rtx_code_label *ashr_end_label;
   rtx test, tmpval, cntr;
 
+  gcc_assert (!reload_completed);
+
   if (const_1_operand (nshifts, VOIDmode))
     {
       emit_insn (gen_ashr<mode>3_single (dst, src, nshifts));
@@ -543,34 +838,82 @@ (define_insn "ashr<mode>3_single"
 ;; DI logical ops could be automatically split into WORD-mode ops in
 ;; expand_binop().  But then we'll miss an opportunity to use SI mode
 ;; operations, since WORD mode for PRU is QI.
-(define_insn "<code>di3"
-  [(set (match_operand:DI 0 "register_operand"		"=&r,&r")
+(define_expand "<code>di3"
+  [(set (match_operand:DI 0 "register_operand")
 	  (LOGICAL_BITOP:DI
-	    (match_operand:DI 1 "register_operand"	"%r,r")
-	    (match_operand:DI 2 "reg_or_ubyte_operand"	"r,I")))]
+	    (match_operand:DI 1 "register_operand")
+	    (match_operand:DI 2 "reg_or_ubyte_operand")))]
   ""
-  "@
-   <logical_bitop_asm>\\t%F0, %F1, %F2\;<logical_bitop_asm>\\t%N0, %N1, %N2
-   <logical_bitop_asm>\\t%F0, %F1, %2\;<logical_bitop_asm>\\t%N0, %N1, 0"
-  [(set_attr "type" "alu")
-   (set_attr "length" "8")])
+{
+  rtx lo_dest, hi_dest;
+  rtx lo_op1, hi_op1, lo_op2, hi_op2;
+  rtx lo_set, hi_set;
+
+  pru_decompose_di_binop (operands[1], operands[2], &lo_op1, &hi_op1,
+			  &lo_op2, &hi_op2);
 
+  lo_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  hi_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_highpart_offset (SImode, DImode));
 
-(define_insn "one_cmpldi2"
-  [(set (match_operand:DI 0 "register_operand"		"=r")
-	(not:DI (match_operand:DI 1 "register_operand"	"r")))]
+  lo_set = gen_rtx_SET (lo_dest, gen_rtx_<CODE> (SImode, lo_op1, lo_op2));
+  hi_set = gen_rtx_SET (hi_dest, gen_rtx_<CODE> (SImode, hi_op1, hi_op2));
+
+  /* We cannot describe "=&r" destination constraint with define_expand.
+     Handle overlapping here.  */
+  if (reg_overlap_mentioned_p (lo_dest, hi_op1)
+      || reg_overlap_mentioned_p (lo_dest, hi_op2))
+    {
+      emit_insn (hi_set);
+      emit_insn (lo_set);
+    }
+  else
+    {
+      emit_insn (lo_set);
+      emit_insn (hi_set);
+    }
+
+  DONE;
+})
+
+(define_expand "one_cmpldi2"
+  [(set (match_operand:DI 0 "register_operand")
+	(not:DI (match_operand:DI 1 "register_operand")))]
   ""
 {
-  /* careful with overlapping source and destination regs.  */
-  gcc_assert (GP_REG_P (REGNO (operands[0])));
-  gcc_assert (GP_REG_P (REGNO (operands[1])));
-  if (REGNO (operands[0]) == (REGNO (operands[1]) + 4))
-    return "not\\t%N0, %N1\;not\\t%F0, %F1";
+  rtx lo_dest, hi_dest;
+  rtx lo_op1, hi_op1;
+  rtx lo_set, hi_set;
+
+  lo_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_lowpart_offset (SImode, DImode));
+  hi_dest = simplify_gen_subreg (SImode, operands[0], DImode,
+				 subreg_highpart_offset (SImode, DImode));
+
+  lo_op1 = simplify_gen_subreg (SImode, operands[1], DImode,
+				subreg_lowpart_offset (SImode, DImode));
+  hi_op1 = simplify_gen_subreg (SImode, operands[1], DImode,
+				subreg_highpart_offset (SImode, DImode));
+
+  lo_set = gen_rtx_SET (lo_dest, gen_rtx_NOT (SImode, lo_op1));
+  hi_set = gen_rtx_SET (hi_dest, gen_rtx_NOT (SImode, hi_op1));
+
+  /* We cannot describe "=&r" destination constraint with define_expand.
+     Handle overlapping here.  */
+  if (reg_overlap_mentioned_p (lo_dest, hi_op1))
+    {
+      emit_insn (hi_set);
+      emit_insn (lo_set);
+    }
   else
-    return "not\\t%F0, %F1\;not\\t%N0, %N1";
-}
-  [(set_attr "type" "alu")
-   (set_attr "length" "8")])
+    {
+      emit_insn (lo_set);
+      emit_insn (hi_set);
+    }
+
+  DONE;
+})
 
 ;; Multiply instruction.  The nop is required to ensure that Rmd0 and Rms0
 ;; registers are sampled and multiplication is executed on those values.
@@ -877,6 +1220,32 @@ (define_insn "cbranch_qbbx_<BIT_TEST:code><EQS0:mode><EQS1:mode><EQD:mode>4"
 	       (le (minus (match_dup 2) (pc)) (const_int 2044)))
 	  (const_int 4)
 	  (const_int 8)))])
+
+(define_insn "cbranch_qbbx_and_<BIT_TEST:code><EQS0:mode><EQS1:mode><EQD:mode>4"
+ [(set (pc)
+   (if_then_else
+    (BIT_TEST (and:EQD
+		(match_operand:EQS0 0 "register_operand" "r")
+	 	(match_operand:EQS1 1 "single_one_operand" "n"))
+     (const_int 0))
+    (label_ref (match_operand 2))
+    (pc)))]
+  ""
+{
+  const int length = (get_attr_length (insn));
+  const bool is_near = (length == 4);
+  if (is_near)
+    return "<BIT_TEST:qbbx_op>\\t%l2, %0, %u1";
+  else
+    return "<BIT_TEST:qbbx_negop>\\t.+8, %0, %u1\;jmp\\t%%label(%l2)";
+}
+  [(set_attr "type" "control")
+   (set (attr "length")
+      (if_then_else
+	  (and (ge (minus (match_dup 2) (pc)) (const_int -2048))
+	       (le (minus (match_dup 2) (pc)) (const_int 2044)))
+	  (const_int 4)
+	  (const_int 8)))])
 
 ;; ::::::::::::::::::::
 ;; ::
@@ -887,12 +1256,29 @@ (define_insn "cbranch_qbbx_<BIT_TEST:code><EQS0:mode><EQS1:mode><EQD:mode>4"
 ;; This insn is volatile because we'd like it to stay in its original
 ;; position, just before the loop header.  If it stays there, we might
 ;; be able to convert it into a "loop" insn.
-(define_insn "@doloop_begin_internal<mode>"
+(define_insn_and_split "@doloop_begin_internal<mode>"
   [(set (match_operand:HISI 0 "register_operand" "=r")
 	(unspec_volatile:HISI
-	 [(match_operand:HISI 1 "reg_or_ubyte_operand" "rI")
+	 [(match_operand:HISI 1 "reg_or_ubyte_operand" "ri")
 	  (match_operand 2 "const_int_operand" "")] UNSPECV_LOOP_BEGIN))]
   ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (match_dup 0)
+	   (unspec_volatile:HISI
+	    [(match_dup 1)
+	     (match_dup 2)] UNSPECV_LOOP_BEGIN))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  "")
+
+(define_insn "@doloop_begin_internal<mode>_cc_clobber"
+  [(set (match_operand:HISI 0 "register_operand" "=r")
+	(unspec_volatile:HISI
+	 [(match_operand:HISI 1 "reg_or_ubyte_operand" "rI")
+	  (match_operand 2 "const_int_operand" "")] UNSPECV_LOOP_BEGIN))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  "reload_completed"
 {
   gcc_unreachable ();
 })
@@ -909,7 +1295,7 @@ (define_expand "doloop_begin"
 ; Note: "JUMP_INSNs and CALL_INSNs are not allowed to have any output
 ; reloads;".  Hence this insn must be prepared for a counter that is
 ; not a register.
-(define_insn "@doloop_end_internal<mode>"
+(define_insn_and_split "@doloop_end_internal<mode>"
   [(set (pc)
 	(if_then_else (ne (match_operand:HISI 0 "nonimmediate_operand" "+r,*m")
 			  (const_int 1))
@@ -921,9 +1307,21 @@ (define_insn "@doloop_end_internal<mode>"
    (unspec [(match_operand 2 "const_int_operand" "")] UNSPECV_LOOP_END)
    (clobber (match_scratch:HISI 3 "=X,&r"))]
   ""
-{
-  gcc_unreachable ();
-}
+  "#"
+  "reload_completed"
+  [(parallel
+     [(set (pc)
+	   (if_then_else (ne (match_dup 0)
+			     (const_int 1))
+			 (label_ref (match_dup 1))
+			 (pc)))
+      (set (match_dup 0)
+	   (plus:HISI (match_dup 0)
+		      (const_int -1)))
+      (unspec [(match_dup 2)] UNSPECV_LOOP_END)
+      (clobber (match_dup 3))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
   ;; Worst case length:
   ;;
   ;;	  lbbo op3_reg, op3_ptr	  4'
@@ -940,6 +1338,31 @@ (define_insn "@doloop_end_internal<mode>"
 	(cond [(eq_attr "alternative" "0") (const_int 12)]
 	       (const_int 20))))])
 
+(define_insn "@doloop_end_internal<mode>_cc_clobber"
+  [(set (pc)
+	(if_then_else (ne (match_operand:HISI 0 "nonimmediate_operand" "+r,*m")
+			  (const_int 1))
+		      (label_ref (match_operand 1))
+		      (pc)))
+   (set (match_dup 0)
+	(plus:HISI (match_dup 0)
+		 (const_int -1)))
+   (unspec [(match_operand 2 "const_int_operand" "")] UNSPECV_LOOP_END)
+   (clobber (match_scratch:HISI 3 "=X,&r"))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  "reload_completed"
+{
+  gcc_unreachable ();
+}
+  [(set (attr "length")
+      (if_then_else
+	(and (ge (minus (pc) (match_dup 1)) (const_int 0))
+	     (le (minus (pc) (match_dup 1)) (const_int 1020)))
+	(cond [(eq_attr "alternative" "0") (const_int 4)]
+	       (const_int 12))
+	(cond [(eq_attr "alternative" "0") (const_int 12)]
+	       (const_int 20))))])
+
 (define_expand "doloop_end"
   [(use (match_operand 0 "nonimmediate_operand"))
    (use (label_ref (match_operand 1 "")))]
@@ -983,21 +1406,53 @@ (define_insn "delay_cycles_end"
   [(set_attr "length" "0")])
 
 
-(define_insn "delay_cycles_2x_plus1_hi"
+(define_insn_and_split "delay_cycles_2x_plus1_hi"
   [(unspec_volatile [(match_operand:SI 0 "const_uhword_operand" "J")]
 		    UNSPECV_DELAY_CYCLES_2X_HI)
    (clobber (match_scratch:SI 1 "=&r"))]
   ""
+  "#"
+  "reload_completed"
+  [(parallel
+     [(unspec_volatile [(match_dup 0)]
+		       UNSPECV_DELAY_CYCLES_2X_HI)
+      (clobber (match_dup 1))
+      (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "length" "12")])
+
+(define_insn "delay_cycles_2x_plus1_hi_cc_clobber"
+  [(unspec_volatile [(match_operand:SI 0 "const_uhword_operand" "J")]
+		    UNSPECV_DELAY_CYCLES_2X_HI)
+   (clobber (match_scratch:SI 1 "=&r"))
+   (clobber (reg:CC_C CARRY_REGNUM))]
+  "reload_completed"
   "ldi\\t%1, %0\;sub\\t%1, %1, 1\;qbne\\t.-4, %1, 0"
   [(set_attr "length" "12")])
 
 
+(define_insn_and_split "delay_cycles_2x_plus2_si"
+  [(unspec_volatile [(match_operand:SI 0 "const_int_operand" "n")]
+		    UNSPECV_DELAY_CYCLES_2X_SI)
+   (clobber (match_scratch:SI 1 "=&r"))]
+  ""
+  "#"
+  "reload_completed"
+  [(parallel
+    [(unspec_volatile [(match_dup 0)]
+		      UNSPECV_DELAY_CYCLES_2X_SI)
+     (clobber (match_dup 1))
+     (clobber (reg:CC_C CARRY_REGNUM))])]
+  ""
+  [(set_attr "length" "16")])
+
 ; Do not use LDI32 here because we do not want
 ; to accidentally loose one instruction cycle.
-(define_insn "delay_cycles_2x_plus2_si"
+(define_insn "delay_cycles_2x_plus2_si_cc_clobber"
   [(unspec_volatile [(match_operand:SI 0 "const_int_operand" "n")]
 		    UNSPECV_DELAY_CYCLES_2X_SI)
-   (clobber (match_scratch:SI 1 "=&r"))]
+   (clobber (match_scratch:SI 1 "=&r"))
+   (clobber (reg:CC_C CARRY_REGNUM))]
   ""
   "ldi\\t%1.w0, %L0\;ldi\\t%1.w2, %H0\;sub\\t%1, %1, 1\;qbne\\t.-4, %1, 0"
   [(set_attr "length" "16")])
diff --git a/gcc/testsuite/gcc.target/pru/adddi-1.c b/gcc/testsuite/gcc.target/pru/adddi-1.c
new file mode 100644
index 00000000000..c56837efa49
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/adddi-1.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_adddi_reg (int64_t a, int64_t b)
+{
+  /* { dg-final { scan-assembler "add\\tr14, r14, r16" } } */
+  /* { dg-final { scan-assembler "adc\\tr15, r15, r17" } } */
+  return a + b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/adddi-2.c b/gcc/testsuite/gcc.target/pru/adddi-2.c
new file mode 100644
index 00000000000..5c5d3673937
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/adddi-2.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_adddi_p255 (int64_t a)
+{
+  /* { dg-final { scan-assembler "add\\tr14, r14, 101" } } */
+  /* { dg-final { scan-assembler "adc\\tr15, r15, 0" } } */
+  return a + 101;
+}
diff --git a/gcc/testsuite/gcc.target/pru/adddi-3.c b/gcc/testsuite/gcc.target/pru/adddi-3.c
new file mode 100644
index 00000000000..a19e6137a45
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/adddi-3.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_adddi_m255 (int64_t a)
+{
+  /* { dg-final { scan-assembler "sub\\tr14, r14, 101" } } */
+  /* { dg-final { scan-assembler "suc\\tr15, r15, 0" } } */
+  return a - 101;
+}
diff --git a/gcc/testsuite/gcc.target/pru/negdi-1.c b/gcc/testsuite/gcc.target/pru/negdi-1.c
new file mode 100644
index 00000000000..b507a3d6a18
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/negdi-1.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_negdi (int64_t a)
+{
+  /* { dg-final { scan-assembler "rsb\\tr14, r14, 0" } } */
+  /* { dg-final { scan-assembler "rsc\\tr15, r15, 0" } } */
+  return -a;
+}
diff --git a/gcc/testsuite/gcc.target/pru/subdi-1.c b/gcc/testsuite/gcc.target/pru/subdi-1.c
new file mode 100644
index 00000000000..7be44ce77f5
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/subdi-1.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_subdi_reg (int64_t a, int64_t b)
+{
+  /* { dg-final { scan-assembler "sub\\tr14, r14, r16" } } */
+  /* { dg-final { scan-assembler "suc\\tr15, r15, r17" } } */
+  return a - b;
+}
diff --git a/gcc/testsuite/gcc.target/pru/subdi-2.c b/gcc/testsuite/gcc.target/pru/subdi-2.c
new file mode 100644
index 00000000000..3e175df0159
--- /dev/null
+++ b/gcc/testsuite/gcc.target/pru/subdi-2.c
@@ -0,0 +1,14 @@
+/* Ensure DI arithmetic operations are split. */
+
+/* { dg-do compile } */
+/* { dg-options "-O1" } */
+
+typedef long long int64_t;
+
+int64_t
+test_subdi_p255 (int64_t a)
+{
+  /* { dg-final { scan-assembler "rsb\\tr14, r14, 101" } } */
+  /* { dg-final { scan-assembler "rsc\\tr15, r15, 0" } } */
+  return 101 - a;
+}
-- 
2.20.1

